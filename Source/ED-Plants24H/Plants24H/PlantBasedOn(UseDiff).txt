// Decompiled with JetBrains decompiler
// Type: RimWorld.Plant
// Assembly: Assembly-CSharp, Version=0.13.5928.30054, Culture=neutral, PublicKeyToken=null
// MVID: 15B18259-40F8-46CF-A467-2A947DDE6EF8
// Assembly location: C:\~Git\Jaxxa-Rimworld\lib\A13.1123\Assembly-CSharp.dll

using System.Text;
using UnityEngine;
using Verse;

namespace RimWorld
{
  [StaticConstructorOnStartup]
  public class Plant : Thing
  {
    private static Color32[] workingColors = new Color32[4];
    private static Graphic GraphicSowing = GraphicDatabase.Get<Graphic_Single>("Things/Plant/Plant_Sowing", ShaderDatabase.Cutout, Vector2.one, Color.white);
    public float growth = 0.05f;
    private int madeLeaflessTick = -99999;
    public const float BaseGrowthPercent = 0.05f;
    private const float RotDamagePerTick = 0.005f;
    private const float GridPosRandomnessFactor = 0.3f;
    private const int TicksWithoutLightBeforeRot = 450000;
    private const int LeaflessMinRecoveryTicks = 60000;
    public const float MinGrowthTemperature = 0.0f;
    public const float MinOptimalGrowthTemperature = 10f;
    public const float MaxOptimalGrowthTemperature = 42f;
    public const float MaxGrowthTemperature = 58f;
    public const float MaxLeaflessTemperature = -2f;
    private const float MinLeaflessTemperature = -10f;
    private const float MinAnimalEatPlantsTemperature = 0.0f;
    public const float SeedShootMinGrowthPercent = 0.6f;
    public int age;
    private int unlitTicks;
    public bool sown;

    public bool HarvestableNow
    {
      get
      {
        if (this.def.plant.Harvestable)
          return (double) this.growth > (double) this.def.plant.harvestMinGrowth;
        return false;
      }
    }

    public override bool IngestibleNow
    {
      get
      {
        return this.def.plant.IsTree || (double) this.growth >= (double) this.def.plant.harvestMinGrowth && !this.LeaflessNow && (double) GridsUtility.GetSnowDepth(this.Position) <= (double) this.def.hideAtSnowDepth;
      }
    }

    public bool Rotting
    {
      get
      {
        return this.def.plant.LimitedLifespan && this.age > this.def.plant.LifespanTicks || this.unlitTicks > 450000;
      }
    }

    private bool Resting
    {
      get
      {
        if ((double) GenDate.CurrentDayPercent >= 0.25)
          return (double) GenDate.CurrentDayPercent > 0.800000011920929;
        return true;
      }
    }

    private float GrowthPerTick
    {
      get
      {
        if (this.LifeStage != PlantLifeStage.Growing || this.Resting)
          return 0.0f;
        return (float) (1.0 / (60000.0 * (double) this.def.plant.growDays)) * this.GrowthRate;
      }
    }

    public float GrowthRate
    {
      get
      {
        return this.GrowthRateFactor_Fertility * this.GrowthRateFactor_Temperature * this.GrowthRateFactor_Light;
      }
    }

    public float GrowthRateFactor_Fertility
    {
      get
      {
        return (float) ((double) this.LocalFertility * (double) this.def.plant.fertilityFactorGrowthRate + (1.0 - (double) this.def.plant.fertilityFactorGrowthRate));
      }
    }

    public float GrowthRateFactor_Light
    {
      get
      {
        return Mathf.Clamp01(Mathf.InverseLerp(this.def.plant.growMinGlow, this.def.plant.growOptimalGlow, Find.GlowGrid.GameGlowAt(this.Position)));
      }
    }

    public float GrowthRateFactor_Temperature
    {
      get
      {
        float tempResult;
        if (!GenTemperature.TryGetTemperatureForCell(this.Position, out tempResult))
          return 1f;
        if ((double) tempResult < 10.0)
          return Mathf.InverseLerp(0.0f, 10f, tempResult);
        if ((double) tempResult > 42.0)
          return Mathf.InverseLerp(58f, 42f, tempResult);
        return 1f;
      }
    }

    private int TicksUntilFullyGrown
    {
      get
      {
        if ((double) this.growth > 0.999899983406067)
          return 0;
        return (int) ((1.0 - (double) this.growth) / (double) this.GrowthPerTick);
      }
    }

    private string GrowthPercentString
    {
      get
      {
        return GenText.ToStringPercent(this.growth + 0.0001f);
      }
    }

    public override string LabelMouseover
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(this.def.LabelCap);
        stringBuilder.Append(" (" + Translator.Translate("PercentGrowth", (object) this.GrowthPercentString));
        if (this.Rotting)
          stringBuilder.Append(", " + Translator.Translate("DyingLower"));
        stringBuilder.Append(")");
        return stringBuilder.ToString();
      }
    }

    private bool HasEnoughLightToGrow
    {
      get
      {
        return (double) this.GrowthRateFactor_Light > 1.0 / 1000.0;
      }
    }

    private float LocalFertility
    {
      get
      {
        return Find.FertilityGrid.FertilityAt(this.Position);
      }
    }

    public PlantLifeStage LifeStage
    {
      get
      {
        if ((double) this.growth < 1.0 / 1000.0)
          return PlantLifeStage.Sowing;
        return (double) this.growth > 0.999000012874603 ? PlantLifeStage.Mature : PlantLifeStage.Growing;
      }
    }

    public override Graphic Graphic
    {
      get
      {
        if (this.LifeStage == PlantLifeStage.Sowing)
          return Plant.GraphicSowing;
        if (this.def.plant.leaflessGraphic != null && this.LeaflessNow)
          return this.def.plant.leaflessGraphic;
        return base.Graphic;
      }
    }

    public bool LeaflessNow
    {
      get
      {
        return Find.TickManager.TicksGame - this.madeLeaflessTick < 60000;
      }
    }

    public override void Destroy(DestroyMode mode = DestroyMode.Vanish)
    {
      base.Destroy(mode);
    }

    public override void SpawnSetup()
    {
      base.SpawnSetup();
      if (Game.Mode != GameMode.MapPlaying)
        return;
      this.CheckTemperatureMakeLeafless();
    }

    public override void ExposeData()
    {
      base.ExposeData();
      Scribe_Values.LookValue<float>(ref this.growth, "growth", 0.0f, false);
      Scribe_Values.LookValue<int>(ref this.age, "age", 0, false);
      Scribe_Values.LookValue<int>(ref this.unlitTicks, "unlitTicks", 0, false);
      Scribe_Values.LookValue<bool>(ref this.sown, "sown", false, false);
    }

    public override void PostMapInit()
    {
      this.CheckTemperatureMakeLeafless();
    }

    public override void Ingested(Pawn eater, float nutritionWanted)
    {
      if (this.def.plant.harvestDestroys)
      {
        this.Destroy(DestroyMode.Vanish);
      }
      else
      {
        this.growth -= 0.3f;
        if ((double) this.growth < 0.0799999982118607)
          this.growth = 0.08f;
        Find.MapDrawer.MapMeshDirty(this.Position, MapMeshFlag.Things);
      }
      float num1 = this.def.ingestible.nutrition;
      float num2 = !this.def.plant.Sowable ? num1 * Mathf.Lerp(0.5f, 1f, this.growth) : num1 * this.growth;
      eater.needs.food.CurLevel += (float) (double) num2;
      eater.records.AddTo(RecordDefOf.NutritionEaten, num2);
    }

    public void PlantCollected()
    {
      if (this.def.plant.harvestDestroys)
      {
        this.Destroy(DestroyMode.Vanish);
      }
      else
      {
        this.growth = 0.08f;
        Find.MapDrawer.MapMeshDirty(this.Position, MapMeshFlag.Things);
      }
    }

    private void CheckTemperatureMakeLeafless()
    {
      float num = 8f;
      if ((double) GridsUtility.GetTemperature(this.Position) >= (double) Gen.HashOffset((Thing) this) * 0.00999999977648258 % (double) num - (double) num - 2.0)
        return;
      this.MakeLeafless();
    }

    public void MakeLeafless()
    {
      bool flag = !this.LeaflessNow;
      this.madeLeaflessTick = Find.TickManager.TicksGame;
      if (this.def.plant.dieIfLeafless)
        this.TakeDamage(new DamageInfo(DamageDefOf.Rotting, 99999, (Thing) null, new BodyPartDamageInfo?(), (ThingDef) null));
      if (!flag)
        return;
      Find.MapDrawer.MapMeshDirty(this.Position, MapMeshFlag.Things);
    }

    public override void TickLong()
    {
      this.CheckTemperatureMakeLeafless();
      if (!GenPlant.GrowthSeasonNow(this.Position))
        return;
      if (!this.HasEnoughLightToGrow)
        this.unlitTicks += 2000;
      else
        this.unlitTicks = 0;
      bool flag = this.LifeStage == PlantLifeStage.Mature;
      this.growth += this.GrowthPerTick * 2000f;
      if (!flag && this.LifeStage == PlantLifeStage.Mature)
        this.NewlyMatured();
      if (this.def.plant.LimitedLifespan)
      {
        this.age += 2000;
        if (this.Rotting)
        {
          int amount = Mathf.CeilToInt(10f);
          this.TakeDamage(new DamageInfo(DamageDefOf.Rotting, amount, (Thing) null, new BodyPartDamageInfo?(), (ThingDef) null));
        }
      }
      if (this.Destroyed || !this.def.plant.shootsSeeds || ((double) this.growth < 0.600000023841858 || !Rand.MTBEventOccurs(this.def.plant.seedEmitMTBDays, 60000f, 2000f)) || (!GenPlant.SnowAllowsPlanting(this.Position) || GridsUtility.Roofed(this.Position)))
        return;
      GenPlantReproduction.TrySpawnSeed(this.Position, this.def, SeedTargFindMode.ReproduceSeed, (Thing) this);
    }

    private void NewlyMatured()
    {
      if (!this.CurrentlyCultivated())
        return;
      Find.MapDrawer.MapMeshDirty(this.Position, MapMeshFlag.Things);
    }

    private bool CurrentlyCultivated()
    {
      if (!this.def.plant.Sowable)
        return false;
      Zone zone = Find.ZoneManager.ZoneAt(this.Position);
      if (zone != null && zone is Zone_Growing)
        return true;
      Building edifice = GridsUtility.GetEdifice(this.Position);
      return edifice != null && edifice.def.building.SupportsPlants;
    }

    public int YieldNow()
    {
      if (!this.HarvestableNow || (double) this.def.plant.harvestYield <= 0.0)
        return 0;
      return GenMath.RoundRandom(this.def.plant.harvestYield * (float) (0.5 + (double) Mathf.InverseLerp(this.def.plant.harvestMinGrowth, 1f, this.growth) * 0.5) * Mathf.Lerp(0.5f, 1f, (float) this.HitPoints / (float) this.MaxHitPoints) * Find.Storyteller.difficulty.cropYieldFactor);
    }

    public override void Print(SectionLayer layer)
    {
      Vector3 vector3 = Gen.TrueCenter((Thing) this);
      Rand.PushSeed();
      Rand.Seed = this.Position.GetHashCode();
      float max1 = this.def.plant.maxMeshCount != 1 ? 0.5f : 0.05f;
      int num1 = Mathf.CeilToInt(this.growth * (float) this.def.plant.maxMeshCount);
      if (num1 < 1)
        num1 = 1;
      int num2 = 1;
      int num3 = this.def.plant.maxMeshCount;
      switch (num3)
      {
        case 1:
          num2 = 1;
          break;
        case 4:
          num2 = 2;
          break;
        default:
          if (num3 != 9)
          {
            if (num3 != 16)
            {
              if (num3 == 25)
              {
                num2 = 5;
                break;
              }
              Log.Error((string) (object) this.def + (object) " must have plant.MaxMeshCount that is a perfect square.");
              break;
            }
            num2 = 4;
            break;
          }
          num2 = 3;
          break;
      }
      float num4 = 1f / (float) num2;
      Vector3 center1 = Vector3.zero;
      Vector2 size = Vector2.zero;
      int num5 = 0;
      foreach (int num6 in PlantPosIndices.GetPositionIndices(this))
      {
        float num7 = this.def.plant.visualSizeRange.LerpThroughRange(this.growth);
        if (this.def.plant.maxMeshCount == 1)
        {
          center1 = vector3 + new Vector3(Rand.Range(-max1, max1), 0.0f, Rand.Range(-max1, max1));
          float num8 = Mathf.Floor(vector3.z);
          if ((double) center1.z - (double) num7 / 2.0 < (double) num8)
            center1.z = num8 + num7 / 2f;
        }
        else
        {
          center1 = this.Position.ToVector3();
          center1.y = this.def.Altitude;
          center1.x += 0.5f * num4;
          center1.z += 0.5f * num4;
          int num8 = num6 / num2;
          int num9 = num6 % num2;
          center1.x += (float) num8 * num4;
          center1.z += (float) num9 * num4;
          float max2 = num4 * 0.3f;
          center1 += new Vector3(Rand.Range(-max2, max2), 0.0f, Rand.Range(-max2, max2));
        }
        bool flag = (double) Rand.Value < 0.5;
        Material matSingle = this.Graphic.MatSingle;
        Plant.workingColors[1].a = Plant.workingColors[2].a = (byte) ((double) byte.MaxValue * (double) this.def.plant.topWindExposure);
        Plant.workingColors[0].a = Plant.workingColors[3].a = (byte) 0;
        float num10 = num7 * this.def.graphicData.drawSize.x;
        size = new Vector2(num10, num10);
        bool flipUv = flag;
        Printer_Plane.PrintPlane(layer, center1, size, matSingle, 0.0f, flipUv, (Vector2[]) null, Plant.workingColors, 0.1f);
        ++num5;
        if (num5 >= num1)
          break;
      }
      if (this.def.graphicData.shadowData != null)
      {
        float num6 = (double) size.y >= 1.0 ? 0.81f : 0.6f;
        Vector3 center2 = center1;
        center2.z -= size.y / 2f * num6;
        center2.y -= 0.05f;
        Printer_Shadow.PrintShadow(layer, center2, this.def.graphicData.shadowData);
      }
      Rand.PopSeed();
    }

    public override string GetInspectString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append(base.GetInspectString());
      if (this.LifeStage == PlantLifeStage.Growing)
      {
        stringBuilder.AppendLine(Translator.Translate("PercentGrowth", (object) this.GrowthPercentString));
        stringBuilder.AppendLine(Translator.Translate("GrowthRate") + ": " + GenText.ToStringPercent(this.GrowthRate));
        if (this.Resting)
        {
          stringBuilder.AppendLine(Translator.Translate("PlantResting"));
        }
        else
        {
          if (!this.HasEnoughLightToGrow)
            stringBuilder.AppendLine(Translator.Translate("PlantNeedsLightLevel") + ": " + GenText.ToStringPercent(this.def.plant.growMinGlow));
          float factorTemperature = this.GrowthRateFactor_Temperature;
          if ((double) factorTemperature < 0.990000009536743)
          {
            if ((double) factorTemperature < 0.00999999977648258)
              stringBuilder.AppendLine(Translator.Translate("OutOfIdealTemperatureRangeNotGrowing"));
            else
              stringBuilder.AppendLine(Translator.Translate("OutOfIdealTemperatureRange", (object) Mathf.RoundToInt(factorTemperature * 100f).ToString()));
          }
        }
      }
      else if (this.LifeStage == PlantLifeStage.Mature)
      {
        if (this.def.plant.Harvestable)
          stringBuilder.AppendLine(Translator.Translate("ReadyToHarvest"));
        else
          stringBuilder.AppendLine(Translator.Translate("Mature"));
      }
      return stringBuilder.ToString();
    }

    public void CropBlighted()
    {
      if ((double) Rand.Value >= 0.850000023841858)
        return;
      this.Destroy(DestroyMode.Vanish);
    }
  }
}
